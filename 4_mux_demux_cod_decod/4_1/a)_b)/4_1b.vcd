$date
  Sun Sep 20 23:37:55 2020
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$scope module standard $end
$upscope $end
$scope module std_logic_1164 $end
$upscope $end
$scope module multiplex_tb $end
$var reg 1 ! s0 $end
$var reg 1 " s1 $end
$var reg 3 # y[2:0] $end
$var reg 3 $ i0[2:0] $end
$var reg 3 % i1[2:0] $end
$var reg 3 & i2[2:0] $end
$var reg 3 ' i3[2:0] $end
$scope module vierportmp $end
$var reg 3 ( i0[2:0] $end
$var reg 3 ) i1[2:0] $end
$var reg 3 * i2[2:0] $end
$var reg 3 + i3[2:0] $end
$var reg 1 , s0 $end
$var reg 1 - s1 $end
$var reg 3 . y[2:0] $end
$var reg 1 / x0 $end
$var reg 1 0 x1 $end
$var reg 1 1 x2 $end
$var reg 1 2 x3 $end
$var reg 1 3 s1not $end
$var reg 1 4 s0not $end
$scope module not0 $end
$var reg 1 5 input1 $end
$var reg 1 6 not_result $end
$upscope $end
$scope module not1 $end
$var reg 1 7 input1 $end
$var reg 1 8 not_result $end
$upscope $end
$scope module and0 $end
$var reg 1 9 input1 $end
$var reg 1 : input2 $end
$var reg 1 ; and_result $end
$var reg 1 < and_gate $end
$upscope $end
$scope module and1 $end
$var reg 1 = input1 $end
$var reg 1 > input2 $end
$var reg 1 ? and_result $end
$var reg 1 @ and_gate $end
$upscope $end
$scope module and2 $end
$var reg 1 A input1 $end
$var reg 1 B input2 $end
$var reg 1 C and_result $end
$var reg 1 D and_gate $end
$upscope $end
$scope module and3 $end
$var reg 1 E input1 $end
$var reg 1 F input2 $end
$var reg 1 G and_result $end
$var reg 1 H and_gate $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
0!
0"
b000 #
b000 $
b001 %
b010 &
b011 '
b000 (
b001 )
b010 *
b011 +
0,
0-
b000 .
1/
00
01
02
13
14
05
16
07
18
19
1:
1;
1<
0=
1>
0?
0@
1A
0B
0C
0D
0E
0F
0G
0H
#10000000
1"
b010 #
1-
b010 .
0/
11
03
17
08
0:
0;
0<
0>
1B
1C
1D
1F
#20000000
1!
0"
b001 #
1,
0-
b001 .
10
01
13
04
15
06
07
18
09
1:
1=
1>
1?
1@
0A
0B
0C
0D
1E
0F
#30000000
1"
b011 #
1-
b011 .
00
12
03
17
08
0:
0>
0?
0@
1B
1F
1G
1H
#40000000
